$ A number of cars are to be produced; they are not identical, because different options are available as variants on the basic model. The assembly line has different stations which install the various options (air-conditioning, sun-roof, etc.). These stations have been designed to handle at most a certain percentage of the cars passing along the assembly line. Furthermore, the cars requiring a certain option must not be bunched together, otherwise the station will not be able to cope. Consequently, the cars must be arranged in a sequence so that the capacity of each station is never exceeded. For instance, if a particular station can only cope with at most half of the cars passing along the line, the sequence must be built so that at most 1 car in any 2 requires that option. The problem has been shown to be NP-complete (Gent 1999).
$ The format of the data files is as follows:
$     First line: number of cars; number of options; number of classes.
$     Second line: for each option, the maximum number of cars with that option in a block.
$     Third line: for each option, the block size to which the maximum number refers.
$     Then for each class: index no.; no. of cars in this class; for each option, whether or not this class requires it (1 or 0). 
$ This is the example given in (Dincbas et al., ECAI88):
$ 10 5 6
$ 1 2 1 2 1
$ 2 3 3 5 5
$ 0 1 1 0 1 1 0 
$ 1 1 0 0 0 1 0 
$ 2 2 0 1 0 0 1 
$ 3 2 0 1 0 1 0 
$ 4 2 1 0 1 0 0 
$ 5 2 1 1 0 0 0 
$ A valid sequence for this set of cars is:
$ Class 	Options req.
$ 0 	1 0 1 1 0
$ 1 	0 0 0 1 0
$ 5 	1 1 0 0 0
$ 2 	0 1 0 0 1
$ 4 	1 0 1 0 0
$ 3 	0 1 0 1 0
$ 3 	0 1 0 1 0
$ 4 	1 0 1 0 0
$ 2 	0 1 0 0 1
$ 5 	1 1 0 0 0


given n_cars, n_classes, n_options : int(1..)
letting Slots  be domain int(1..n_cars),
        Class  be domain int(1..n_classes),
        Option be domain int(1..n_options),
given quantity      : function (total) Class  --> int(1..),
      maxcars       : function (total) Option --> int(1..),
      blksize_delta : function (total) Option --> int(1..),
      usage         : relation (minSize 1) of ( Class * Option )
$ There must be at least as many cars as there are n_classes as quantity is indexed from 1..
where n_cars >= n_classes
$ The sum of the cars in the quantity function should equal n_cars 
where ( sum quant : Class . quantity(quant) ) = n_cars
$ Blksize must be greater than maxcars for all options
$ where forAll option: Option . maxcars(option) < blksize(option)
$ Make sure that all options are used at least once
where  forAll option: Option .  |toSet(usage(_,option))| >= 1
$ Make sure that all classes have at least one option
where  forAll class: Class .  |toSet(usage(class,_))| >= 1
find car : function (total) Slots --> Class
such that
    forAll c : Class . |preImage(car,c)| = quantity(c),
    forAll opt : Option .
        forAll s : int(1..n_cars+1-(maxcars(opt)+blksize_delta(opt))) .
            (sum i : int(s..s+(maxcars(opt)+blksize_delta(opt))-1) . toInt(usage(car(i),opt))) <= maxcars(opt)